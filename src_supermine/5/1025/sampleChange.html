<link rel="stylesheet" href="../../../../default.css">
<script src="../../../../highlight.pack.js"></script> 
<script>hljs.initHighlightingOnLoad();</script>
<html><h3></h3><h3>Before Change</h3><pre><code class='java'>
    smaller window sizes (the output windows are concentric).
    
    if data is None or data.get(&quotsampler&quot, None) is None:
        <a id="change">raise tf.logging.fatal("input weight map not found. please check"
                               "the configuration file")</a>
    n_samples = max(n_samples, 1)
    uniq_spatial_size = set([img_size[:N_SPATIAL]
                             for img_size in list(img_sizes.values())])
    if len(uniq_spatial_size) &gt; 1:</code></pre><h3>After Change</h3><pre><code class='java'>
    &#47&#47 the window might be. If the centre of the window was outside of
    &#47&#47 this crop area, the patch would be outside of the field of view
    half_win = np.floor(max_spatial_win / 2).astype(int)
    <a id="change">try:
        cropped_map = data[&quotsampler&quot][
            half_win[0]:-half_win[0] if max_spatial_win[0] &gt; 1 else 1,
            half_win[1]:-half_win[1] if max_spatial_win[1] &gt; 1 else 1,
            half_win[2]:-half_win[2] if max_spatial_win[2] &gt; 1 else 1,
            0, 0]
        assert np.all(cropped_map.shape) &gt; 0
    except (IndexError, KeyError):
        tf.logging.fatal("incompatible map: %s", data[&quotsampler&quot].shape)
        raise
    except AssertionError:
        tf.logging.fatal(
            "incompatible window size for weighted sampler. "
            "Please use smaller (fully-specified) spatial window sizes")
        raise
    &#47&#47 Get the cumulative sum of the normalised sorted intensities
    &#47&#47 i.e. first sort the sampling frequencies, normalise them
    &#47&#47 to sum to one, and then accumulate them in order
   </a> flatten_map = cropped_map.flatten()
    sorted_data = np.cumsum(np.divide(np.sort(flatten_map), flatten_map.sum()))
    &#47&#47 get the sorting indexes to that we can invert the sorting later on.
    sorted_indexes = np.argsort(flatten_map)</code></pre>